# EventPing Database Schema

## Overview
This document describes the expected database schema that will be auto-generated by Hibernate when the application starts.

## Database Configuration
- **Database**: PostgreSQL
- **Name**: `eventping`
- **User**: `eventping_user`
- **DDL Mode**: `update` (Hibernate auto-generates schema)

---

## Tables

### 1. `users`
Stores event creators and application users.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | BIGSERIAL | PRIMARY KEY | Auto-increment user ID |
| email | VARCHAR(255) | UNIQUE, NOT NULL | User email address |
| full_name | VARCHAR(255) | | User's full name |
| phone_number | VARCHAR(255) | | User's phone number |
| created_at | TIMESTAMP | NOT NULL | Record creation timestamp |
| updated_at | TIMESTAMP | NOT NULL | Last update timestamp |

**Indexes:**
- PRIMARY KEY on `id`
- UNIQUE INDEX on `email`

---

### 2. `plans`
Subscription plans (FREE/PRO) with rate limits.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | BIGSERIAL | PRIMARY KEY | Auto-increment plan ID |
| name | VARCHAR(255) | UNIQUE, NOT NULL | Plan name enum (FREE/PRO) |
| max_events_per_day | INTEGER | NOT NULL | Daily event creation limit |
| max_participants_per_event | INTEGER | NOT NULL | Per-event participant capacity |
| reminder_channels | VARCHAR(255) | NOT NULL | Comma-separated channels |
| price | DECIMAL(19,2) | NOT NULL | Plan price |

**Indexes:**
- PRIMARY KEY on `id`
- UNIQUE INDEX on `name`

**Seeded Data:**
```sql
INSERT INTO plans (name, max_events_per_day, max_participants_per_event, reminder_channels, price) VALUES
('FREE', 3, 50, 'EMAIL', 0.00),
('PRO', 999, 500, 'EMAIL,WHATSAPP', 9.99);
```

---

### 3. `events`
Core event records with public sharing capability.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | BIGSERIAL | PRIMARY KEY | Auto-increment event ID |
| title | VARCHAR(255) | NOT NULL | Event title |
| description | TEXT | | Event description |
| event_date_time | TIMESTAMP | NOT NULL | When the event occurs |
| status | VARCHAR(255) | NOT NULL | ACTIVE or EXPIRED |
| slug | VARCHAR(255) | UNIQUE, NOT NULL | Public URL identifier |
| creator_id | BIGINT | FOREIGN KEY → users.id, NOT NULL | Event creator |
| created_at | TIMESTAMP | NOT NULL | Record creation timestamp |

**Indexes:**
- PRIMARY KEY on `id`
- UNIQUE INDEX on `slug`
- INDEX on `creator_id` (foreign key)
- INDEX on `status, event_date_time` (for expiry queries)

**Foreign Keys:**
- `creator_id` REFERENCES `users(id)` ON DELETE CASCADE

---

### 4. `participants`
Opt-in records for event reminders.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | BIGSERIAL | PRIMARY KEY | Auto-increment participant ID |
| event_id | BIGINT | FOREIGN KEY → events.id, NOT NULL | Associated event |
| email | VARCHAR(255) | NOT NULL | Participant email |
| joined_at | TIMESTAMP | NOT NULL | When participant joined |
| unsubscribed | BOOLEAN | NOT NULL, DEFAULT false | Opt-out status |

**Indexes:**
- PRIMARY KEY on `id`
- INDEX on `event_id` (foreign key)
- INDEX on `event_id, email` (uniqueness check)

**Foreign Keys:**
- `event_id` REFERENCES `events(id)` ON DELETE CASCADE

---

### 5. `reminders`
Scheduled notifications tied to events and participants.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | BIGSERIAL | PRIMARY KEY | Auto-increment reminder ID |
| event_id | BIGINT | FOREIGN KEY → events.id, NOT NULL | Associated event |
| participant_id | BIGINT | FOREIGN KEY → participants.id, NOT NULL | Recipient |
| send_at | TIMESTAMP | NOT NULL | When to send reminder |
| channel | VARCHAR(255) | NOT NULL | EMAIL or WHATSAPP |
| sent | BOOLEAN | NOT NULL, DEFAULT false | Delivery status |
| sent_at | TIMESTAMP | | Actual send timestamp |

**Indexes:**
- PRIMARY KEY on `id`
- INDEX on `event_id` (foreign key)
- INDEX on `participant_id` (foreign key)
- **CRITICAL INDEX**: `send_at, sent` (for cron job queries)

**Foreign Keys:**
- `event_id` REFERENCES `events(id)` ON DELETE CASCADE
- `participant_id` REFERENCES `participants(id)` ON DELETE CASCADE

---

## Entity Relationships Diagram

```
users (1) ──────< (many) events
                    │
                    ├──────< (many) participants
                    │           │
                    │           └──────< (many) reminders
                    │
                    └──────< (many) reminders
```

**Cascade Rules:**
- Deleting a user → deletes all their events
- Deleting an event → deletes all participants and reminders
- Deleting a participant → deletes all their reminders

---

## Critical Queries for Cron Jobs

### 1. Find Due Reminders (runs every minute)
```sql
SELECT * FROM reminders 
WHERE send_at <= NOW() 
AND sent = false;
```

### 2. Find Expired Events (runs hourly)
```sql
SELECT * FROM events 
WHERE status = 'ACTIVE' 
AND event_date_time < NOW();
```

### 3. Cleanup Old Reminders (runs daily)
```sql
DELETE FROM reminders 
WHERE sent = true 
AND sent_at < NOW() - INTERVAL '30 days';
```

---

## Rate Limiting Queries

### Check Event Creation Limit
```sql
SELECT COUNT(*) FROM events 
WHERE creator_id = ? 
AND created_at >= CURRENT_DATE;
```

### Check Participant Capacity
```sql
SELECT COUNT(*) FROM participants 
WHERE event_id = ?;
```

---

## Verification Steps

### 1. Check Tables Created
```sql
\dt
```
Expected output: `users`, `plans`, `events`, `participants`, `reminders`

### 2. Verify Plans Seeded
```sql
SELECT * FROM plans;
```
Expected: 2 rows (FREE, PRO)

### 3. Check Foreign Keys
```sql
SELECT
    tc.table_name, 
    kcu.column_name, 
    ccu.table_name AS foreign_table_name,
    ccu.column_name AS foreign_column_name
FROM information_schema.table_constraints AS tc 
JOIN information_schema.key_column_usage AS kcu
  ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage AS ccu
  ON ccu.constraint_name = tc.constraint_name
WHERE tc.constraint_type = 'FOREIGN KEY';
```

### 4. Check Indexes
```sql
SELECT tablename, indexname, indexdef 
FROM pg_indexes 
WHERE schemaname = 'public' 
ORDER BY tablename, indexname;
```

---

## Notes

- All timestamps are stored in UTC
- Hibernate will auto-create indexes on:
  - Primary keys
  - Foreign keys
  - Unique constraints
- Additional indexes may be needed for performance:
  - Composite index on `(send_at, sent)` in reminders table
  - Index on `(status, event_date_time)` in events table
